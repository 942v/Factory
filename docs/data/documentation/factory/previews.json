{"primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Factory can make SwiftUI Previews easier when we’re using View Models and those view models depend on internal dependencies. Let’s take a look.","type":"text"}]},{"anchor":"SwiftUI-Integrations","type":"heading","level":2,"text":"SwiftUI Integrations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory can be used in SwiftUI to assign a dependency to a "},{"type":"codeVoice","code":"StateObject"},{"type":"text","text":" or "},{"code":"ObservedObject","type":"codeVoice"},{"text":".","type":"text"}]},{"syntax":"swift","code":["struct ContentView: View {","    @StateObject private var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Keep in mind that if you assign to an "},{"code":"ObservedObject","type":"codeVoice"},{"text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes).","type":"text"}]},{"level":2,"text":"SwiftUI Previews","type":"heading","anchor":"SwiftUI-Previews"},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of updating a view model’s service dependency in order to setup a particular state for  preview.","type":"text"}]},{"code":["struct ContentView: View {","    @StateObject var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}","","struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we can control where the view model gets its data then we can put the view model into pretty much any state we choose."},{"type":"text","text":" "},{"text":"\u0004","type":"text"}]},{"anchor":"SwiftUI-Previews","type":"heading","text":"SwiftUI #Previews","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The same can be done for the new #Preview option, with one minor change."}]},{"code":["#Preview {","    let _ = Container.myService.register { MockServiceN(4) }","    return ContentView()","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The #Preview closure is not a ViewBuilder, so if we add our let statement we just need to explicitly return our view.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Or we could simply turn it into a ViewBuilder using our old friend, Group.","type":"text"}]},{"type":"codeListing","code":["#Preview {","    Group {","        let _ = Container.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"Group actually has a few additional uses…","type":"text"}],"type":"paragraph"},{"anchor":"Multiple-Previews","level":2,"type":"heading","text":"Multiple Previews"},{"inlineContent":[{"type":"text","text":"If we want to do multiple previews at once, each with different data, we simply need to instantiate our view models and pass them into the view as parameters."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Given the ContentView we used above…"}]},{"syntax":"swift","type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        Group {","            let _ = Container.shared.myService.register { MockServiceN(4) }","            let vm1 = ContentViewModel()","            ContentView(viewModel: vm1)","            ","            let _ = Container.shared.myService.register { MockServiceN(8) }","            let vm2 = ContentViewModel()","            ContentView(viewModel: vm2)","        }","    }","}"]},{"text":"InjectedObject","anchor":"InjectedObject","type":"heading","level":2},{"inlineContent":[{"text":"Should you prefer, you can also use ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"type":"text","text":", an immediate injection property wrapper for SwiftUI ObservableObjects."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This wrapper is meant for use in SwiftUI Views and exposes bindable objects similar to that of SwiftUI @StateObject"},{"type":"text","text":" "},{"type":"text","text":"and @EnvironmentObject."}]},{"type":"paragraph","inlineContent":[{"text":"Like the other Injected property wrappers, InjectedObject wraps obtains the dependency from the Factory keypath","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and provides it to a wrapped instance of StateObject."}]},{"code":["struct ContentView: View {","    @InjectedObject(\\.contentViewModel) var model","    var body: some View {","        ...","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"ContentViewModel must, of course, be of type ObservableObject and is registered like any other service","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or dependency."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}"]},{"inlineContent":[{"type":"text","text":"As with StateObject and ObservedObject, updating the object’s state will trigger a view update."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"InjectedObject is also handy when…"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"You have a service that could be consumed from a view or a view model.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"You have view model dependencies that depend on the Graph scope and you need the view model to be the graph’s root. See ","type":"text"},{"isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","type":"reference"},{"type":"text","text":" for more details on graph."}],"type":"paragraph"}]}]},{"level":2,"type":"heading","text":"InjectedObject Previews","anchor":"InjectedObject-Previews"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Single previews work exactly the same."}]},{"type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"But due a bug in how Swift manages property wrappers with built in initializers, doing multiple previews is just a little different than shown earlier.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        Group {","            let _ = Container.shared.myServiceType.register { MockServiceN(44) }","            let model1 = ContentViewModel()","            ContentView(model: InjectedObject(model1))","            ","            let _ = Container.shared.myServiceType.register { MockServiceN(88) }","            let model2 = ContentViewModel()","            ContentView(model: InjectedObject(model2))","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Instead of passing the model to the view directly, we need to create the entire ","type":"text"},{"code":"InjectedObject(model1)","type":"codeVoice"},{"type":"text","text":" pair and pass that."}]},{"anchor":"Common-Setup","type":"heading","level":2,"text":"Common Setup"},{"inlineContent":[{"text":"If we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Container {","    func setupMocks() {","        myService.register { MockServiceN(4) }","        sharedService.register { MockService2() }","    }","}","","struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.setupMocks()","        ContentView()","    }","}"]}],"kind":"content"}],"sections":[],"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"Factory"}],"title":"SwiftUI Previews"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factory\/previews"]}],"seeAlsoSections":[{"generated":true,"title":"Development and Testing","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Testing","doc:\/\/Factory\/documentation\/Factory\/Contexts","doc:\/\/Factory\/documentation\/Factory\/Debugging","doc:\/\/Factory\/documentation\/Factory\/Chains"]}],"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Previews","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"kind":"article","references":{"doc://Factory/documentation/Factory":{"abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","role":"collection","url":"\/documentation\/factory","title":"Factory"},"doc://Factory/documentation/Factory/Contexts":{"abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"type":"topic","role":"article","title":"Contexts","kind":"article","url":"\/documentation\/factory\/contexts","identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},"doc://Factory/documentation/Factory/Debugging":{"title":"Debugging","url":"\/documentation\/factory\/debugging","abstract":[{"text":"Additional support for debugging resolution cycles, dependency chains and other issue.","type":"text"}],"kind":"article","identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging","type":"topic","role":"article"},"doc://Factory/documentation/Factory/Scopes":{"title":"Scopes","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","role":"collectionGroup","url":"\/documentation\/factory\/scopes","abstract":[{"text":"Not everything wants to be a Singleton. Learn the power of Scopes.","type":"text"}],"kind":"article"},"doc://Factory/documentation/Factory/Testing":{"title":"Testing","url":"\/documentation\/factory\/testing","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}],"kind":"article","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","type":"topic","role":"article"},"doc://Factory/documentation/Factory/Chains":{"title":"Circular Dependency Chains","url":"\/documentation\/factory\/chains","abstract":[{"text":"Detecting and solving Circular Dependency Chains.","type":"text"}],"kind":"article","identifier":"doc:\/\/Factory\/documentation\/Factory\/Chains","type":"topic","role":"article"}}}