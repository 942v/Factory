{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory"},{"type":"text","text":" manages the dependency injection process for a specific object or service and produces an object of the desired type when required."}]},{"anchor":"Defining-a-Factory","level":3,"type":"heading","text":"Defining a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define that a given dependency is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory, as you may have guessed from the name, is no exception. Here’s a simple registration that returns a "},{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" dependency."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        Factory(self) { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To accomplish that we need to extend a Factory "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container"},{"type":"text","text":". Within that container we define a new computed variable of type "},{"type":"codeVoice","code":"Factory<ServiceType>"},{"type":"text","text":". This type must be explicity defined, and is usually a protocol to which the returned dependency conforms."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside the computed variable we construct our Factory, providing it with a refernce to its container (self) and also with a factory closure that’s used tp create an instance of our object when needed. That Factory is then returned to the caller, usually to be evaluated (see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()"},{"type":"text","text":"). Every time we resolve resolve the returned factory we’ll get a new, unique instance of our object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like SwftUI Views, Factory structs and modifiers are lightweight and transitory value types. Ther’re created when needed and then immediately discarded once their purpose has been served."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Containers also provide a convenient shortcut that will do the factory creation and binding to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" for us."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        makes { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations"},{"type":"text","text":"."}]},{"anchor":"Resolving-a-Factory","level":3,"type":"heading","text":"Resolving a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To resolve a Factory and obtain an object or service of the desired type, one simply calls the Factory as s function. Here we use the "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container that’s provided for each and every container type."}]},{"type":"codeListing","syntax":"swift","code":["let service = Container.shared.service()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The resolved instance may be brand new or Factory may return a cached value from the specified "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re passing an instance of a container around to your views or view models, just call it directly."}]},{"type":"codeListing","syntax":"swift","code":["let service = container.service()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, you can also use the @Injected property wrapper and specify a keyPaths to the desired dependency."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\.service) var service: ServiceType"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unless otherwise specified, the @Injected property wrapper looks for dependencies in the standard shared container provided by Factory, so the above example is functionally identical to the "},{"type":"codeVoice","code":"Container.shared.service()"},{"type":"text","text":" example shown earlier. Here’s one pointing to your own container."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\MyCustomContainer.service) var service: ServiceType"]},{"anchor":"Registering-a-new-Factory-closure","level":3,"type":"heading","text":"Registering a new Factory closure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"What happens if we want to change the behavior of a Factory? What if the system requires changes during runtime, or what if we want our factory to provide mocks and testing doubles?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy. Just register a new closure with the existing Factory."}]},{"type":"codeListing","syntax":"swift","code":["container.service.register {","    MockService()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new factory closure overrides the original factory closure and clears the associated scope so that the next time this factory is resolved Factory will evaluate the new closure and return an instance of the newly registered object instead."}]},{"style":"warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Registration “overrides” and scope caches are stored in the associated container. If that container ever goes out of scope, so will all of its registrations and cached objects."}]}],"type":"aside","name":"Warning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples of container passing and Factory resolutions see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"kind":"article","metadata":{"modules":[{"name":"Factory"}],"role":"collectionGroup","title":"Getting Started"},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"topicSections":[{"title":"Examples","abstract":[{"type":"text","text":"Some code samples demonstration various ways to regsiter and resolve Factory’s."}],"identifiers":["doc:\/\/Factory\/documentation\/Factory\/Registrations","doc:\/\/Factory\/documentation\/Factory\/Resolutions"]}],"references":{"doc://Factory/documentation/Factory/Container":{"role":"symbol","title":"Container","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Container"}],"abstract":[{"type":"text","text":"This is the default Container provided for your convenience by Factory."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Container"}],"url":"\/documentation\/factory\/container"},"doc://Factory/documentation/Factory/Factory/callAsFunction()":{"role":"symbol","title":"callAsFunction()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"callAsFunction"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"T"}],"abstract":[{"type":"text","text":"Evaluates the factory and returns an object or service of the desired type. The resolved instance may be brand new or Factory may"},{"type":"text","text":" "},{"type":"text","text":"return a cached value from the specified scope."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()","kind":"symbol","type":"topic","url":"\/documentation\/factory\/factory\/callasfunction()"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Factory":{"role":"symbol","title":"Factory","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Factory"}],"abstract":[{"type":"text","text":"A Factory manages the dependency injection process for a specific object or service and produces an object of the desired type"},{"type":"text","text":" "},{"type":"text","text":"when required. This may be a brand new instance or Factory may return a previously cached value from the specified scope."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Factory"}],"url":"\/documentation\/factory\/factory"},"doc://Factory/documentation/Factory/Scope":{"role":"symbol","title":"Scope","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Scope"}],"abstract":[{"type":"text","text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,"},{"type":"text","text":" "},{"type":"text","text":"including "},{"type":"codeVoice","code":"Singleton"},{"type":"text","text":", "},{"type":"codeVoice","code":"Cached"},{"type":"text","text":", "},{"type":"codeVoice","code":"Graph"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Shared"},{"type":"text","text":"."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Scope"}],"url":"\/documentation\/factory\/scope"},"doc://Factory/documentation/Factory/Registrations":{"role":"article","title":"Sample Registrations","abstract":[],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations","kind":"article","type":"topic","url":"\/documentation\/factory\/registrations"},"doc://Factory/documentation/Factory/Resolutions":{"role":"article","title":"Sample Resolutions","abstract":[],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","kind":"article","type":"topic","url":"\/documentation\/factory\/resolutions"}}}