{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are quite a few dependency injection libraries and systems available for Swift. In fact, there are so many that I’m begining to think that writing your own is considered to be some sort of rite of passage for an iOS developer."}]},{"anchor":"Considerations","level":2,"type":"heading","text":"Considerations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While choosing any dependency injection system can be a subjective choice, I think a few objective considerations are also in order:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Is it safe?"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Is it easy to use?"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Is it flexible, or does it force the application into using a specific dependency injection style or pattern?"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Are there any performance penalties to consider?"}]}]}]},{"anchor":"The-Competition","level":2,"type":"heading","text":"The Competition"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here are a few of the major competitors out there, along with my thoughts on some of the pros and cons associated with each. I’m also rating each of them on the above categories on a score from 1 (low) to 5 (high)."}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Library"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Safe"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Easy"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Flex"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Perf"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Cleanse"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"4"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"3"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"1"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"4"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Needle"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Resolver"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swinject"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"-"}]}]]],"header":"row"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So let’s talk about them. Note that I’m splitting these out into several distinct categories based on how each one works internally."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This section is incomplete and in process. Check back again later."}]}],"type":"aside","name":"Note"},{"anchor":"Type-Lookup-Libraries","level":2,"type":"heading","text":"Type-Lookup Libraries"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most Type-Lookup libraries work by registering a set of types that can be resolved at a later point in time. These systems, while quite powerful and still in use in many applications, suffer from a couple of drawbacks."}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"They typically require pre-registration of all services up front."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"They use type inference or specification to dynamically find and return registered services from a container."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first drawback is relatively minor. While preregistration could lead to a performance hit on application launch, in practice the process is usually quick and not normally noticeable."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second issue, however, is more problematic since failure to find a matching registration for that type during runtime can lead to an application crash."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And that’s why, in fact, why I created Factory."}]},{"anchor":"Cleanse","level":3,"type":"heading","text":"Cleanse"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet to be added."}]},{"anchor":"Resolver","level":3,"type":"heading","text":"Resolver"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet to be added."}]},{"anchor":"Swinject","level":3,"type":"heading","text":"Swinject"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet to be added."}]},{"anchor":"SwiftUI-Environment-Style-Libraries","level":2,"type":"heading","text":"SwiftUI Environment-Style Libraries"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are several SwiftUI Environment-Style libraries out there, all based on the pattern used by SwiftUI when creating new Environment Keys."}]},{"anchor":"Dependencies","level":3,"type":"heading","text":"Dependencies"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-dependencies"},{"type":"text","text":" is a small dependency injection library that uses “DependencyKeys” in a manner similar to that of SwiftUI EnvironmentKeys. This means, unfortunately, that each and every injection definition looks like the following:"}]},{"type":"codeListing","syntax":"swift","code":["private enum APIClientKey: DependencyKey {","    static let liveValue = APIClient.live","}","extension DependencyValues {","    var apiClient: APIClient {","        get { self[APIClientKey.self] }","        set { self[APIClientKey.self] = newValue }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s a lot of boilerplate for a single dependency registration."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Resolving the dependency typically occurs using a property wrapper similar to Factory’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected"},{"type":"text","text":"’."}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureModel: ObservableObject {","    @Dependency(\\.apiClient) var api","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies’ test and mocking capabilities are somewhat limited."}]},{"type":"codeListing","syntax":"swift","code":["func testAdd() async throws {","    let model = withDependencies {","        $0.api = MockAPI()","    } operation: {","        FeatureModel()","    }","    \/\/ test the model","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As shown, one can use this and other strategies to update the dependencies on "},{"type":"codeVoice","code":"FeatureModel"},{"type":"text","text":". It doesn’t, however, let you reach deeper into the dependency tree and change a dependency inside of a dependency inside of a dependency like you can with Factory."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, note that in order to mutate the "},{"type":"codeVoice","code":"FeatureModel"},{"type":"text","text":" the api parameter can not be private. It must be expeosed to the outside world."}]},{"anchor":"Compile-Time-Libraries","level":2,"type":"heading","text":"Compile-Time Libraries"},{"anchor":"Needle","level":3,"type":"heading","text":"Needle"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet to be added."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/competition"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Competition","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"How Factory stacks up against the competition."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Competiton","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Addtional Topics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Migration"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Injected":{"role":"symbol","title":"Injected","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Injected"}],"abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Injected"}],"url":"\/documentation\/factory\/injected"},"https://github.com/pointfreeco/swift-dependencies":{"title":"Dependencies","titleInlineContent":[{"type":"text","text":"Dependencies"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-dependencies","url":"https:\/\/github.com\/pointfreeco\/swift-dependencies"},"doc://Factory/documentation/Factory/Migration":{"role":"article","title":"Migration","abstract":[{"type":"text","text":"Moving from 1.x to 2.0"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Migration","kind":"article","type":"topic","url":"\/documentation\/factory\/migration"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"}}}