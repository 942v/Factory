{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Circular-Dependency-Chain-Detection","level":2,"type":"heading","text":"Circular Dependency Chain Detection"},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s a circular dependency? Let’s say that A needs B to be constructed, and B needs a C. But what happens if C needs an A?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Examine the following class definitions."}]},{"type":"codeListing","syntax":"swift","code":["class CircularA {","    @Injected(\\.circularB) var circularB","}","","class CircularB {","    @Injected(\\.circularC) var circularC","}","","class CircularC {","    @Injected(\\.circularA) var circularA","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Attempting make an instance of "},{"type":"codeVoice","code":"CircularA"},{"type":"text","text":" is going to result in an infinite loop."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Why? Well, A’s injected property wrapper needs a B in to construct an A. Okay, fine. Let’s make one. But B’s wrapper needs a C, which can’t be made without injecting an A, which once more needs a B… and so on. Ad infinitum."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a circular dependency chain."}]},{"anchor":"Resolution","level":2,"type":"heading","text":"Resolution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, by the time this code is compiled and run it’s too late to break the cycle. We’ve effectively coded an infinite loop into our program. All Factory can do in this case is die gracefully and in the process dump the dependency chain that indicates where the problem lies."}]},{"type":"codeListing","syntax":null,"code":["2022-12-23 14:57:23.512032-0600 FactoryDemo[47546:6946786] Factory\/Factory.swift:393: ","Fatal error: circular dependency chain - CircularA > CircularB > CircularC > CircularA"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With the above information in hand we should be able to find the problem and fix it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We could fix things by chaging CircularC’s injection wrapper to "},{"type":"codeVoice","code":"LazyInjected"},{"type":"text","text":" or, better yet, "},{"type":"codeVoice","code":"WeakLazyInjected"},{"type":"text","text":" in order to avoid a retain cycle. But a better solution would probably entail finding and breaking out the functionality that "},{"type":"codeVoice","code":"CircularA"},{"type":"text","text":" and "},{"type":"codeVoice","code":"CircularC"},{"type":"text","text":" are depending upon into a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"third"}]},{"type":"text","text":" object they both could include."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Circular dependencies such as this are usually a violation of the Single Responsibility Principle, and should be avoided."}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Note: Due to the overhead involved, circular dependency detection only occurs when running the application in DEBUG mode. The code is stripped out of production builds for improved performance."}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/chains"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Chains","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Circular Dependency Chains","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Advanced Topics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Testing","doc:\/\/Factory\/documentation\/Factory\/Optionals","doc:\/\/Factory\/documentation\/Factory\/Functional"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","kind":"article","type":"topic","url":"\/documentation\/factory\/testing"},"doc://Factory/documentation/Factory/Optionals":{"role":"article","title":"Optionals and Dynamic Registration","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Optionals","kind":"article","type":"topic","url":"\/documentation\/factory\/optionals"},"doc://Factory/documentation/Factory/Previews":{"role":"article","title":"SwiftUI Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews","kind":"article","type":"topic","url":"\/documentation\/factory\/previews"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Functional":{"role":"article","title":"Functional Injection","abstract":[{"type":"text","text":"Factory can inject more than service classes and structs."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Functional","kind":"article","type":"topic","url":"\/documentation\/factory\/functional"}}}