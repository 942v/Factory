{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Containers are used by Factory to manage object creation, object resolution, and object lifecycles in general."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Factory 1.0 with its statically defined Factory’s a “container” was really just a convenient namespace. But in Factory 2.0 a container is a distinct object that can be referenced, passed around, and deallocated as needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can even create separate instances of the same container type, each with its own registrations and scope caches."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory 2.0 supports true container-based dependency injection."}]},{"anchor":"Containers-and-Factorys","level":2,"type":"heading","text":"Containers and Factory’s"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A Factory definition is a computed property defined within a container extension. Each Factory needs a reference to its container, and also requires a factory closure that will produce our dependency when asked to do so."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Put it all together, and you have the following:"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        Factory(self) { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also ask the enclosing container to make our Factory for us. The following definition provides the same result as the one above."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<MyServiceType> {","        self { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you’ve added a Factory to a container you can resolve it."}]},{"type":"codeListing","syntax":"swift","code":["let service = Container.shared.service()"]},{"anchor":"The-Default-Container","level":2,"type":"heading","text":"The Default Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory ships with a single "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container"},{"type":"text","text":" already constructed for your convenience."}]},{"type":"codeListing","syntax":"swift","code":["public final class Container: SharedContainer {","    public static var shared = MyContainer()","    public var manager = ContainerManager()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You’ve seen it used and extended in all of the examples we’ve seen thus far, and most projects can simply extend it and go."}]},{"anchor":"Containershared","level":2,"type":"heading","text":"Container.shared"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As the default Container definition shows, each container class defined has a statically allocated "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" instance associated with it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This instance can be referenced directly if you’re using a Service Locator-style pattern."}]},{"type":"codeListing","syntax":"swift","code":["let service = Container.shared.service()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or you can use the “shared” container as an application root container and pass it along to whereever it’s needed. Let’s take a look."}]},{"anchor":"Passing-Containers","level":2,"type":"heading","text":"Passing Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of passing an instance of a container to a view model and then initializing a service from that container."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel {","    let service2: MyServiceType","    init(container: Container) {","        service2 = container.service()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Addtional examples and methods can be seen on the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions"},{"type":"text","text":" page."}]},{"anchor":"SharedContainer","level":2,"type":"heading","text":"SharedContainer"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All containers conform to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/SharedContainer"},{"type":"text","text":" protocol. That basically means that each one must have its own "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager"},{"type":"text","text":" and implement a static "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" instance."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SharedContainer also defines some common functionality for each container, like the afrementioned "},{"type":"codeVoice","code":"makes"},{"type":"text","text":" convenience function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that you can extend SharedContainer with your own Factory’s."}]},{"type":"codeListing","syntax":"swift","code":["extension SharedContainer {","    var commonSerice: Factory<ServiceType> {","        self { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"commonSerice"},{"type":"text","text":" Factory will now be available on every container created."}]},{"type":"codeListing","syntax":"swift","code":["let common1 = Container.shared.commonService()","let common2 = MyContainer.shared.commonService()"]},{"anchor":"Custom-Containers","level":2,"type":"heading","text":"Custom Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a large project you might want to segregate factories into additional, smaller containers."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Definiing your own container class is simple. Just use the following as a template."}]},{"type":"codeListing","syntax":"swift","code":["public final class MyContainer: SharedContainer {","     public static var shared = MyContainer()","     public var manager = ContainerManager()","}","","extension MyContainer {","    var cachedService: Factory<ServiceType> {","        self { MyService() }.cached","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As mentioned, a contaimer must derive from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/SharedContainer"},{"type":"text","text":", have its own "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager"},{"type":"text","text":", and implement a static "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" instance. It also must be marked "},{"type":"codeVoice","code":"final"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t forget that if need be you can reach across containers simply by specifying the full container.factory path."}]},{"type":"codeListing","syntax":"swift","code":["extension PaymentsContainer {","    let anotherService = Factory<AnotherService> { ","        self { AnotherService(using: Container.shared.optionalService()) }","    }","}"]},{"anchor":"Injected-Property-Wrappers","level":2,"type":"heading","text":"Injected Property Wrappers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Property wrappers like @Injected and @LazyInjected always reference the "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container for that class type. Let’s get an instance of the "},{"type":"codeVoice","code":"cachedService"},{"type":"text","text":" object we defined above by providing a keypath to the desired class and service."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel: ObservableObject {","    @Injected(\\MyContainer.cachedService) var cachedService","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We now have an instance of "},{"type":"codeVoice","code":"cachedService"},{"type":"text","text":" in our view model, as well as a reference to the same instance cached in "},{"type":"codeVoice","code":"MyContainer.shared.manager"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected"},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected"},{"type":"text","text":" for more."}]},{"anchor":"Registration-and-Scope-Management","level":2,"type":"heading","text":"Registration and Scope Management"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As mentioned earlier, factory registrations and scopes are managed by the container on which the dependency was created. Adding a registration or clearing a scope cache on one container has no effect on any other container."}]},{"type":"codeListing","syntax":"swift","code":["let containerA = MyContainer()","containerA.register.cachedService { MockService() }","","\/\/ Will have a MockService","let service1 = containerA.cachedService() ","","\/\/ Will have a new or prevously cached instance of ServiceType","let service2 = MyContainer.shared.cachedService() "]},{"anchor":"AutoRegister","level":2,"type":"heading","text":"AutoRegister"},{"type":"paragraph","inlineContent":[{"type":"text","text":"From time to time you may find that you need to register or change some instances prior to application initialization. If so you can do the following."}]},{"type":"codeListing","syntax":"swift","code":["extension Container: AutoRegistering {","    func autoRegister() {","        someService.register { ModuleB.SomeService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just make "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" conform to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/AutoRegistering"},{"type":"text","text":" and provide the "},{"type":"codeVoice","code":"autoRegister"},{"type":"text","text":" function. This function will be called "},{"type":"emphasis","inlineContent":[{"type":"text","text":"once"}]},{"type":"text","text":" prior to the very first Factory service resolution on that container."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that this can come in handy when you want to register instances of objects obtained across differe modules."}]},{"anchor":"Resetting-a-Container","level":2,"type":"heading","text":"Resetting a Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using register on a factory lets us change the state of the system. But what if we need to revert back to the original behavior?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Simple. Just reset it to bring back the original factory closure. Or, if desired, you can reset "},{"type":"emphasis","inlineContent":[{"type":"text","text":"everything"}]},{"type":"text","text":" back to square one with a single command."}]},{"type":"codeListing","syntax":"Swift","code":["container.myService.reset() \/\/ resets this factory only","container.manager.reset() \/\/ clears all registrations and caches"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also reset registrations and scope caches specifically, leaving the other intact."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Reset all registrations, restoring original factories but leaving caches intact","Container.shared.manager.reset(options: .registration)","","\/\/ Reset all scope caches, leaving registrations intact","Container.shared.manager.reset(options: .scope)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also reset a specific scope cache while leaving the others intact."}]},{"type":"codeListing","syntax":"swift","code":["Container.shared.manager.reset(scope: .cached)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that resetting registrations also resets the container’s auto registration flag."}]},{"style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Resetting a container or scope has no effect whatsoever on anything that’s alreay been resolved by Factory. It only ensures that the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"next"}]},{"type":"text","text":" time a Factory is asked to resolve a dependency that dependency will be a new instance."}]}],"type":"aside","name":"Important"},{"anchor":"Pushing-and-Popping-State","level":2,"type":"heading","text":"Pushing and Popping State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with Factory 1.0, the state of a container’s registrations and scope caches can be saved (pushed), and then restored (popped)."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Save the current state","Container.shared.manager.push()","","\/\/ Make a change","Container.shared.someService.register { MockService() }","","\/\/ Pop the change and restore the manager's state to what it was before the registration.","Container.shared.manager.pop()","","\/\/ Gets the original or previously registered service.","let service = Container.shared.someService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can be handy in an unit test environment. Keep in mind that push\/pop uses a stack, so it’s possible to push and pop as many times as are needed."}]},{"anchor":"Releasing-a-Container","level":2,"type":"heading","text":"Releasing a Container"},{"style":"warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a container ever goes out of scope, so will all of its registrations and cached objects."}]}],"type":"aside","name":"Warning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To demonstrate, let’s see what happens when we create and assign a new container to "},{"type":"codeVoice","code":"MyContainer.shared"},{"type":"text","text":". Doing so releases the provious container, along with any registrations or objects that container may have cached. We’ll use the "},{"type":"codeVoice","code":"cachedService"},{"type":"text","text":" Factory we defined above."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create an instance of our cached service.","let service1 = MyContainer.shared.cachedService()","","\/\/ Repeat, which returns the same cached instance we obtained in service1.","let service2 = MyContainer.shared.cachedService()","assert(service1.id == service2.id)","","\/\/ Replace the existing shared container with a new one.","MyContainer.shared = MyContainer()","","\/\/ Trying again gets a new instance since the old container and cache was released.","let service3 = MyContainer.shared.cachedService()","assert(service1.id != service3.id)","","\/\/ Repeat and receive the same cached instance we obtained in service3.","let service4 = MyContainer.shared.cachedService()","assert(service3.id == service4.id)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"From a certain point of view, replacing a container with a new one is the ultimate reset mechanism."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/containers"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Containers","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?"}],"kind":"article","metadata":{"roleHeading":"Article","title":"Containers","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"The Basics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/GettingStarted","doc:\/\/Factory\/documentation\/Factory\/Scopes","doc:\/\/Factory\/documentation\/Factory\/Migration"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Injected":{"role":"symbol","title":"Injected","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Injected"}],"abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Injected"}],"url":"\/documentation\/factory\/injected"},"doc://Factory/documentation/Factory/Resolutions":{"role":"article","title":"Sample Resolutions","abstract":[{"type":"text","text":"There are many ways to use Factory to resolve dependencies. Here are a few examples."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","kind":"article","type":"topic","url":"\/documentation\/factory\/resolutions"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Container":{"role":"symbol","title":"Container","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Container"}],"abstract":[{"type":"text","text":"This is the default Container provided for your convenience by Factory."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Container"}],"url":"\/documentation\/factory\/container"},"doc://Factory/documentation/Factory/WeakLazyInjected":{"role":"symbol","title":"WeakLazyInjected","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WeakLazyInjected"}],"abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type the first time the wrapped value is requested."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WeakLazyInjected"}],"url":"\/documentation\/factory\/weaklazyinjected"},"doc://Factory/documentation/Factory/Scopes":{"role":"collectionGroup","title":"Scopes","abstract":[{"type":"text","text":"Not everything wants to be a Singleton. Learn the power of Scopes."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","kind":"article","type":"topic","url":"\/documentation\/factory\/scopes"},"doc://Factory/documentation/Factory/SharedContainer":{"role":"symbol","title":"SharedContainer","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SharedContainer"}],"abstract":[{"type":"text","text":"SharedContainer defines the protocol all Containers must adopt."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/SharedContainer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SharedContainer"}],"url":"\/documentation\/factory\/sharedcontainer"},"doc://Factory/documentation/Factory/GettingStarted":{"role":"collectionGroup","title":"Getting Started","abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/factory\/gettingstarted"},"doc://Factory/documentation/Factory/Migration":{"role":"article","title":"Migration","abstract":[{"type":"text","text":"Moving from 1.x to 2.0"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Migration","kind":"article","type":"topic","url":"\/documentation\/factory\/migration"},"doc://Factory/documentation/Factory/LazyInjected":{"role":"symbol","title":"LazyInjected","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LazyInjected"}],"abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type the first time the wrapped value is requested."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LazyInjected"}],"url":"\/documentation\/factory\/lazyinjected"},"doc://Factory/documentation/Factory/AutoRegistering":{"role":"symbol","title":"AutoRegistering","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AutoRegistering"}],"abstract":[{"type":"text","text":"Adds an registration “hook” to a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/AutoRegistering","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AutoRegistering"}],"url":"\/documentation\/factory\/autoregistering"},"doc://Factory/documentation/Factory/ContainerManager":{"role":"symbol","title":"ContainerManager","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ContainerManager"}],"abstract":[{"type":"text","text":"ContainerManager encapsulates and manages the registration, resolution, and scope caching mechanisms for a given container."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ContainerManager"}],"url":"\/documentation\/factory\/containermanager"}}}