{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A resolution cycle is kicked off the instant you ask a Factory to resolve its dependency and return an instance of the desired object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You ask for a dependency, and in the process it asks for it’s dependencies, and so on, until everyone has what it needs to do its job."}]},{"type":"codeListing","syntax":"swift","code":["let demo = Container.shared.cycleDemo()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So w asked, and Factory was more than happy to make a demo object for us. But let’s consider what happened under the hood."}]},{"anchor":"The-Players","level":2,"type":"heading","text":"The Players"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider the following set of classes and protocols:"}]},{"type":"codeListing","syntax":"swift","code":["class CycleDemo {","    @Injected(\\.aService) var aService: AServiceType","    @Injected(\\.bService) var bService: BServiceType","}","","public protocol AServiceType: AnyObject {","    var id: UUID { get }","}","","public protocol BServiceType: AnyObject {","    var text: String","}","","class ImplementsAB: AServiceType, BServiceType {","    @Injected(\\.networkService) var networkService","    var id: UUID = UUID()","    var text: String = \"AB\"","}","","class NetworkService {","    @LazyInjected(\\.preferences) var preferences","}","","class Preferences {","    \/\/ some code","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"CycleDemo is a class that depends on two protocols, both of which are implemented in ImplementsAB. That class, in turn, requires a NetworkService. And that service wants a preferences object."}]},{"anchor":"The-Registrations","level":2,"type":"heading","text":"The Registrations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So let’s look next at the Factory registrations."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var cycleDemo: Factory<CycleDemo> {","        self { CycleDemo() }","    }","    var aService: Factory<AServiceType> {","        self { self.implementsAB() }","    }","    var bService: Factory<BServiceType> {","        self { self.implementsAB() }","    }","    var networkService: Factory<NetworkService> {","        self { NetworkService() }","    }","    var preferences: Factory<Preferences> {","        self { Preferences() }","    }","    private var implementsAB: Factory<AServiceType&BServiceType> {","        self { ImplementsAB() }.graph","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when we ask Factory to make an instance of CycleDemo it calls the factory closure and asks Swift to make an instance of the object. But in order for that object to complete initialization it first needs resolve the two injected property wrappers, starting with aService."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So Factory is called again to make an aService. But that Factory punts and calls "},{"type":"emphasis","inlineContent":[{"type":"text","text":"another"}]},{"type":"text","text":" Factory to get an instance of implementsAB."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That Factory, in turn, asks Swift to make ImplementsAB, but again, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"that"}]},{"type":"text","text":" object needs to initialize with a NetworkService. Another call through Factory."}]},{"anchor":"Tracing-the-Resolution-Cycle","level":2,"type":"heading","text":"Tracing the Resolution Cycle"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s see what we’d get if we put print statements inside each of our Factory’s."}]},{"type":"codeListing","syntax":null,"code":["Container.cycleDemo","Container.aService","Container.implementsAB","Container.networkService","Container.bService","Container.implementsAB"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Again, cycleDemo wants an aService from implementsAB, which wants a networkService. That’s returned, and so an initialized ImplementsAB is returned, and finally aService is returned. Now cycleDemo wants an bService from implementsAB."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But implementsAB was cached in the graph scope, and so the same instance is returned (and which is why we don’t see networkService resolved again)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And now, finally, Swift can return a fully initialized isntance of CycleDemo."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s a resolution cycle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You ask for a dependency, and in the process it asks for it’s dependencies, and so on, until everyone has what it needs to do its job."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the initial result is returned that resolution cycle is over."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Until next time."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/cycle"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Cycle","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"kind":"article","metadata":{"roleHeading":"Article","title":"Resolution Cycle","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Advanced Topics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Testing","doc:\/\/Factory\/documentation\/Factory\/Optionals","doc:\/\/Factory\/documentation\/Factory\/Functional","doc:\/\/Factory\/documentation\/Factory\/Chains"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Optionals":{"role":"article","title":"Optionals and Dynamic Registration","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Optionals","kind":"article","type":"topic","url":"\/documentation\/factory\/optionals"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Functional":{"role":"article","title":"Functional Injection","abstract":[{"type":"text","text":"Factory can inject more than service classes and structs."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Functional","kind":"article","type":"topic","url":"\/documentation\/factory\/functional"},"doc://Factory/documentation/Factory/Chains":{"role":"article","title":"Circular Dependency Chains","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Chains","kind":"article","type":"topic","url":"\/documentation\/factory\/chains"},"doc://Factory/documentation/Factory/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","kind":"article","type":"topic","url":"\/documentation\/factory\/testing"},"doc://Factory/documentation/Factory/Previews":{"role":"article","title":"SwiftUI Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews","kind":"article","type":"topic","url":"\/documentation\/factory\/previews"}}}