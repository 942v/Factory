{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you want to use a dependency injection system like Factory with multiple modules you often run into a “Who’s on first” dilemma."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say that we have a ModuleP which specifies an abstract AccountLoading protocol."}]},{"type":"codeListing","syntax":"swift","code":["public protocol AccountLoading {","    func load() -> [Account]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Moving on, we have an accounting module, ModuleA, that displays our accounts, but needs one of those loaders to load them."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, we have one more module, let’s call this one ModuleB, that knows how to build loaders of any type that we need."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that ModuleA and ModuleB are independent. Neither one knows about the other one, but both have a direct dependency on ModuleP, our master of models and protocols."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a classic modular contractural pattern."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But we have an application to build. So how does ModuleA get an instance of an account loader, when it knows nothing about ModuleB?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s take a look."}]},{"anchor":"Implementation-in-same-module-as-protocol","level":2,"type":"heading","text":"Implementation in same module as protocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before we answer the above question, let’s look at a related, but simpler problem."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say we have a module called Networking that provides (suprise, suprise) a service that conforms to a Networking prototol. Let’s also say that module "},{"type":"emphasis","inlineContent":[{"type":"text","text":"also"}]},{"type":"text","text":" provides the implementation of that service."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In that case our implementation is simple. We define the public protocol "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" we also publicaly define the Factory that provides it."}]},{"type":"codeListing","syntax":"swift","code":["public protocol Networking {","    func load<T>() async throws -> T","}","","extension Container {","    public var network: Factory<Networking> { self { Network() } }","}","","private class Network: Networking {","    public func load<T>() async throws -> T {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our implementation is private and hidden to the rest of the world, which only sees and receives some instance that conforms to our Networking protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Got it? Anything which can see our protocol can also see a source that provides that protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Okay, let’s return to our orginally scheduled program."}]},{"anchor":"Implementation-in-different-module-from-protocol","level":2,"type":"heading","text":"Implementation in different module from protocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To recap, we have a protocol that’s defined in ModuleP. The concrete type AccountLoader exists in ModuleB… but ModuleA doesn’t know about it. It can’t know about."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But the code in ModuleA needs to be able to see a Factory in order to resolve it. And that Factory must have a definition, but it can’t, because it can’t see ModuleB."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Who’s on first?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s a dilemma, but fortunately it’s not a serious one. The solution is twofold."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, we implement part of the “same module” solution show above, but with a twist, adding the following Factory defintion to ModuleP."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    public var accountLoading: Factory<AccountLoading?> { self { nil } }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, as with our earlier solution, anyone who imports ModuleP can see the protocol and can also see a Factory that promises to provide one."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That Factory, however, doesn’t know how to construct one, and so we make its defintion optional. As such, we also prrovide it with a Factory closure that also returns nothing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we go into our main application and create a spot where we can cross-wire all of the pieces of our application together."}]},{"type":"codeListing","syntax":"swift","code":["import ModuleP","import ModuleA","import ModuleB","","extension Container: AutoRegistering {","    func autoRegister {","        accountLoader.register { AccountLoader() }","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This file can see all of the modules, and as such is tasked with registering a new factory closure with "},{"type":"codeVoice","code":"accountLoader"},{"type":"text","text":" that provides an actual instance of "},{"type":"codeVoice","code":"AccountLoader"},{"type":"text","text":" from ModuleB."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And… that’s it. Prior to the first resolution Factory will call "},{"type":"codeVoice","code":"autoRegister"},{"type":"text","text":" in order to setup everything needed for the application to run."}]},{"anchor":"Optionals","level":2,"type":"heading","text":"Optionals"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our code will need to account for the optional service in actual use."}]},{"type":"codeListing","syntax":"swift","code":["class ViewModel: ObservableObject {","    @Injected(\\.accountLoader) var loader","    @Published var accounts: [Account] = []","    func load() {","        guard let loader else { return }","        accounts = loader.load()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But that’s the price we pay for compile-time safety. Should we fail to cross-wire a module dependency, our application isn’t going to crash. It may not run correctly, but it isn’t going to crash."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AutomaticRegistration.swift"},{"type":"text","text":" file in the demo application illustrates a few examples of the cross-module registration technique. Check it out."}]},{"anchor":"Explicitly-Unwrapped-Factories","level":2,"type":"heading","text":"Explicitly Unwrapped Factories"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We could, of course, do the following."}]},{"type":"codeListing","syntax":"swift","code":["class ViewModel: ObservableObject {","    @Injected(\\.accountLoader) var loader: AccountLoading!","    @Published var accounts: [Account] = []","    func load() {","        accounts = loader.load()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We could… but let’s not do that, shall we? Explicitly unwrapping the optional works if we’ve wired everything together, but could crash if we haven’t."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which sort of defeats Factory’s primary goal in life."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Safety."}]},{"anchor":"Resolver","level":2,"type":"heading","text":"Resolver"},{"type":"paragraph","inlineContent":[{"type":"text","text":"My earlier dependency injection library, Resolver, was a bit simpler in handling these cases. You simply asked Resolver for the desired type… and that was it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But the flip side of that equation is that once again, if we’d slipped up somewhere and failed to register a needed dependency… then application went boom."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/modules"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Modules","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Using Factory in a project with multiple modules."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Protocols and Modular Development","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Advanced Topics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Design","doc:\/\/Factory\/documentation\/Factory\/Cycle","doc:\/\/Factory\/documentation\/Factory\/Optionals","doc:\/\/Factory\/documentation\/Factory\/Functional"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Design":{"role":"article","title":"Designing Factory","abstract":[{"type":"text","text":"Rationale behind the design decisions made in Factory 1.0 and 2.0"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Design","kind":"article","type":"topic","url":"\/documentation\/factory\/design"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Functional":{"role":"article","title":"Functional Injection","abstract":[{"type":"text","text":"Factory can inject more than service classes and structs."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Functional","kind":"article","type":"topic","url":"\/documentation\/factory\/functional"},"doc://Factory/documentation/Factory/Optionals":{"role":"article","title":"Optionals and Dynamic Registration","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Optionals","kind":"article","type":"topic","url":"\/documentation\/factory\/optionals"},"doc://Factory/documentation/Factory/Cycle":{"role":"article","title":"Resolution Cycles","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Cycle","kind":"article","type":"topic","url":"\/documentation\/factory\/cycle"}}}