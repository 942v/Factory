{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory has a few additional provisions added to make unit testing easier. Let’s take a look."}]},{"anchor":"Pushing-and-Popping-State","level":2,"type":"heading","text":"Pushing and Popping State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your unit test setUp function you can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"push"}]},{"type":"text","text":" the current state of the registration system and then register and test anything you want."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then in the teardown you can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pop"}]},{"type":"text","text":" the stack, eliminating all of your changes and restoring the container to its original state before the push."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This lets each set of tests start from the same state, irregardless of what the prior tests had changed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example assumes we’re using the shared container."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        super.setUp()","        Container.shared.manager.push()","        Container.shared.setupMocks()","    }","    ","    override func tearDown() {","        super.tearDown()","        Container.shared.manager.pop()","    }","    ","    func testSomething() throws {","        Container.shared.myServiceType.register(factory: { MockService() })","        let model = Container.shared.someViewModel()","        model.load()","        XCTAssertTrue(model.isLoaded)","    }","","    func testError() throws {","        Container.shared.myServiceType.register(factory: { MockErrorService() })","        let model = Container.shared.someViewModel()","        model.load()","        XCTAssertTrue(model.isError)","    }","}"]},{"anchor":"Rebuilding-The-Container","level":2,"type":"heading","text":"Rebuilding The Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your unit test setUp function you can also just create a new container and start over from scratch. No teardown needed."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        super.setUp()","        Container.shared = Container()","        Container.shared.setupMocks()","    }","    ","    func testSomething() throws {","        Container.shared.myServiceType.register(factory: { MockService() })","        let model = Container.shared.someViewModel()","        model.load()","        XCTAssertTrue(model.isLoaded)","    }","}"]},{"anchor":"Passed-Containers","level":2,"type":"heading","text":"Passed Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or you can pass the container into the view model itself."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    var container: Container!","","    override func setUp() {","        super.setUp()","        container = Container()","        container.setupMocks()","    }","    ","    func testSomething() throws {","        container.myServiceType.register(factory: { MockService() })","        let model = MyViewModel(container: container)","        model.load()","        XCTAssertTrue(model.isLoaded)","    }","}"]},{"anchor":"Xcode-UI-Testing","level":2,"type":"heading","text":"Xcode UI Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can use the autoregistration feature mentioned earlier to help us out when running UI Tests. The test case is fairly straightforward."}]},{"type":"codeListing","syntax":"swift","code":["import XCTest","","final class FactoryDemoUITests: XCTestCase {","    func testExample() throws {","        let app = XCUIApplication()","        app.launchArguments.append(\"-mock1\")","        app.launch()","","        let welcome = app.staticTexts[\"Mock Number 1! for Michael\"]","        XCTAssert(welcome.exists)","    }","}   "]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then in the application we check the launch arguments to see what registrations we might want to change."}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Factory","","#if DEBUG","extension Container: AutoRegistering {","    public func autoRegister() {","        if ProcessInfo().arguments.contains(\"-mock1\") {","            myServiceType.register { MockServiceN(1) }","        }","    }","}","#endif"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Obviously, one can add as many different test cases and registrations as needed."}]},{"anchor":"Common-Setup","level":2,"type":"heading","text":"Common Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As shown above, if we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    func setupMocks() {","        myService.register { MockServiceN(4) }","        sharedService.register { MockService2() }","    }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Testing","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Testing","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Development and Testing","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Debugging","doc:\/\/Factory\/documentation\/Factory\/Chains"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Chains":{"role":"article","title":"Circular Dependency Chains","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Chains","kind":"article","type":"topic","url":"\/documentation\/factory\/chains"},"doc://Factory/documentation/Factory/Debugging":{"role":"article","title":"Debugging","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issus."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging","kind":"article","type":"topic","url":"\/documentation\/factory\/debugging"},"doc://Factory/documentation/Factory/Previews":{"role":"article","title":"SwiftUI Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews","kind":"article","type":"topic","url":"\/documentation\/factory\/previews"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"}}}