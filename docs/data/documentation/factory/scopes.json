{"metadata":{"modules":[{"name":"Factory"}],"role":"collectionGroup","title":"Scopes"},"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Scopes","interfaceLanguage":"swift"},"sections":[],"abstract":[{"type":"text","text":"Not everything wants to be a Singleton. Learn the power of Scopes."}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/Factory\/documentation\/Factory\/GettingStarted","doc:\/\/Factory\/documentation\/Factory\/Containers"],"title":"The Basics"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factory\/scopes"]}],"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’ve used Resolver or some other dependency injection system before then you’ve probably experienced the benefits and power of scopes."}]},{"inlineContent":[{"text":"And if not, the concept is easy to understand: Just how long should an instance of an object live?","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You’ve no doubt stuffed an instance of a class into a static variable and created a singleton at some point in your career. This is an example of a scope. A single instance is created and then used and shared by all of the methods and functions in the app.","type":"text"}]},{"inlineContent":[{"text":"This is easily done in Factory.","type":"text"}],"type":"paragraph"},{"level":2,"type":"heading","text":"Singleton","anchor":"Singleton"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just specify a singleton factory."}]},{"code":["extension Container {","    var myService: Factory<MyServiceType> { ","        self { MyService() }","            .singleton","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Now whenever someone requests an instance of "},{"type":"codeVoice","code":"myService"},{"type":"text","text":" they’ll get the same instance of the object as everyone else."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let a = container.myService()","let b = container.myService()"]},{"inlineContent":[{"type":"text","text":"When we do this, both "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" refer to the same instance."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Singletons are easy to create, but they should be used with care. Like static singletons you might create in your own code, using singleton scopes can become problematic when testing your code and often require special handling. See "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing"},{"text":" for more information on how to handle this.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Another issue to keep in mind is that singletons are global, meaning that they’re ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"type":"text","text":" managed or cached by any specific container. If we create two instances of the above container and resolve "},{"type":"codeVoice","code":"myService"},{"text":" from both, we’ll get the ","type":"text"},{"inlineContent":[{"text":"same","type":"text"}],"type":"emphasis"},{"type":"text","text":" instance from both."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then again, that’s kind of the idea, isn’t it?"}]},{"type":"paragraph","inlineContent":[{"text":"Just keep in mind with Factory you have other options. Only use define a scope as singleton when there’s an overriding need for there to be one ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"and only one","type":"text"}]},{"text":" instance of an object.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"So what do we do if we need our object to be cached?","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Just say so.","type":"text"}]},{"type":"heading","text":"Cached","level":2,"anchor":"Cached"},{"type":"paragraph","inlineContent":[{"text":"Cached items are persisted until the cache is reset or the container is deallocated. Consider the following Factory registration.","type":"text"}]},{"code":["extension Container {","    var cachedService: Factory<MyServiceType> { ","        self { MyService() }.cached","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Now let’s resolve it.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let a = container.cachedService()","let b = container.cachedService()"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"When we do this we see that both ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"text":" reference the same instance, just as we saw with the singleton example above.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Cached scopes are Factory’s workhorses. They make unit testing a lot easier and should be your first choice when you’re looking for a caching solution.","type":"text"}]},{"text":"Shared","level":2,"anchor":"Shared","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Shared items exist just as long as someone holds a strong reference to them. When the last reference goes away, the weakly held shared reference also goes away.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var sharedService: Factory<MyServiceType> { ","        self { MyService() }.shared","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Now let’s resolve it.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ resolution","var a = container.sharedService()","var b = container.sharedService()","\/\/ zap all strong references","a = nil","b = nil","\/\/ resolve it again","var c = container.sharedService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When "},{"code":"a","type":"codeVoice"},{"type":"text","text":" was resolved it was cached in the shared cache. When "},{"type":"codeVoice","code":"b"},{"type":"text","text":" is resolved it’s pulled from the cache as we might expect. But when the last strong external reference to "},{"type":"codeVoice","code":"a"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"b"},{"text":" is released (set to nil in the example), the weak reference maintained by the shared cache is also released.","type":"text"}]},{"inlineContent":[{"text":"So when we resolve ","type":"text"},{"code":"c","type":"codeVoice"},{"text":" we’re going to get a new instance, and the cycle proceeds anew.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Custom-Scopes","type":"heading","text":"Custom Scopes"},{"type":"paragraph","inlineContent":[{"text":"You can also add your own special purpose caches to the mix. Try this.","type":"text"}]},{"type":"codeListing","code":["extension Scope {","    static let session = Cached()","}","","extension Container {","    var authenticatedUser: Factory<AuthenticatedUser> { ","        self { AuthenticatedUser() }","            .scope(.session)","    }","    var profileImageCache: Factory<ProfileImageCache> { ","        self { ProfileImageCache() } ","            .scope(.session)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once created, a single instance of "},{"code":"AuthenticatedUser","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"ProfileImageCache","type":"codeVoice"},{"type":"text","text":" will be provided to anyone that needs one… up until the point where the session scope is reset, perhaps by a user logging out."}]},{"type":"codeListing","code":["func logout() {","    Container.shared.manager.reset(scope: .session)","        ...","    }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One note: Like shared variables in custom containers, don’t forget to define the new scope as a ‘let’ variable, not ‘var’. Defining it as a ‘static var’ will cause Swift to issue concurrency warnings in the future whenever that variable is accessed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom scopes are powerful tools to have in your arsenal. Use them."}]},{"text":"Graph Scope","level":2,"anchor":"Graph-Scope","type":"heading"},{"inlineContent":[{"text":"There’s one additional scope, called ","type":"text"},{"type":"codeVoice","code":"graph"},{"type":"text","text":". This scope will reuse any factory instances resolved during a given resolution cycle. This can come in handy when a single class implements multiple protocols. Consider the following…"}],"type":"paragraph"},{"code":["class ProtocolConsumer {","    @Injected(\\.idProvider) var ids","    @Injected(\\.valueProvider) var values","    init() {}","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"ProtocolConsumer"},{"text":" wants two different protocols. But it doesn’t know that a single class provides both services. (Nor should it care.) Take a look at the referenced factories.","type":"text"}]},{"type":"codeListing","code":["extension Container {","    \/\/ the root","    var consumer: Factory<ProtocolConsumer> { self { ProtocolConsumer() } }","    \/\/ the interfaces","    var idProvider: Factory<IDProviding> { self { commonProviding() } }","    var valueProvider: Factory<ValueProviding> { self { commonProviding() } }","    \/\/ the common implementation","    private var commonProviding: Factory<MyService> { self { MyService() }.graph }","}"],"syntax":"swift"},{"inlineContent":[{"text":"Both provider factories reference the same factory. When Factory is asked for an instance of ","type":"text"},{"code":"consumer","type":"codeVoice"},{"type":"text","text":", both providers will receive the same instance of "},{"type":"codeVoice","code":"MyService"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are a few caveats and considerations for using graph. The first is that anyone who wants to participate in the graph needs to explicitly state as such using the graph scope. Note the scope parameter for "},{"code":"commonProviding","type":"codeVoice"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"The second is that there needs to be a “root” to the graph.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In the above example, the "},{"code":"consumer","type":"codeVoice"},{"text":" object is the root. Factory is asked for a consumer, which in turn requires two providers.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If you were to instantiate an instance of ","type":"text"},{"type":"codeVoice","code":"ProtocolConsumer"},{"type":"text","text":" yourself, each one of ProtocolConsumer’s Injected property wrappers would initialize sequentially on the same thread, resulting in two separate and distinct resolution cycles."}]},{"inlineContent":[{"type":"text","text":"See: "},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Cycle","isActive":true,"type":"reference"},{"text":" for more on this.","type":"text"}],"type":"paragraph"},{"text":"Unique","type":"heading","level":2,"anchor":"Unique"},{"inlineContent":[{"text":"The last scope we’re going to discuss is ","type":"text"},{"code":"unique","type":"codeVoice"},{"type":"text","text":". When unique is specified a new instance of the service will be instantiated and returned each and every time one is requested from the factory."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Everyone gets a new, unique instance."}]},{"type":"paragraph","inlineContent":[{"text":"Unique.","type":"text"}]},{"anchor":"Default-Scope","type":"heading","text":"Default Scope","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory’s can have their scopes defined in two different ways:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"We can use a scope modifier, as we’ve shown above.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We don’t specify a scope at all, in which case the scope "},{"inlineContent":[{"text":"usually","type":"text"}],"type":"emphasis"},{"type":"text","text":" defaults to "},{"type":"codeVoice","code":"unique"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"The key word here is ","type":"text"},{"inlineContent":[{"type":"text","text":"usually"}],"type":"emphasis"},{"type":"text","text":", because Factory lets you control the default scope on a per-container basis."}]},{"code":["extension Container: AutoRegistering {","    func autoRegister() {","        manager.defaultScope = .cached","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Now any Factory registration resolved on that container that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"doesn’t specify a scope of its own"}]},{"type":"text","text":" will use the "},{"code":"cached","type":"codeVoice"},{"text":" scope by default.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Lifecycles","text":"Lifecycles","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Scope caches for all types except singletons are maintained by the Factory’s container."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If I create an instance of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" and use it to resolve "},{"code":"cachedService","type":"codeVoice"},{"type":"text","text":" three times, I’ll get the same instance of the object each time."}]},{"syntax":"swift","code":["let a = container.cachedService()","let b = container.cachedService()","let c = container.cachedService()"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In this example, a, b, and c are identical.","type":"text"}]},{"inlineContent":[{"text":"But if we create two instances of the above container and resolve ","type":"text"},{"type":"codeVoice","code":"cachedService"},{"text":" from both, we’ll get two different instances of the service.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let a = container1.cachedService()","let b = container2.cachedService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Scope is managed by the container."}]},{"name":"Warning","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a container ever goes out of scope, so will all of its registrations and cached objects."}]}],"style":"warning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"See the “Releasing a Container” discussion in "},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","isActive":true,"type":"reference"},{"text":" for more information.","type":"text"}]},{"anchor":"TimeToLive","type":"heading","text":"TimeToLive","level":2},{"inlineContent":[{"type":"text","text":"Factory provides a “time to live” option for scoped dependencies."}],"type":"paragraph"},{"code":["extension Container {","    var authenticatedUser: Factory<AuthenticatedUser> { ","        self { AuthenticatedUser() }","            .scope(.session)","            .timeToLive(60 * 20) \/\/ (60 seconds * 20) = 20 minutes","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As shown above, set a time to live for 20 minutes and any new request for that dependency that occurs "},{"inlineContent":[{"text":"after","type":"text"}],"type":"emphasis"},{"type":"text","text":" that period will discard the previously cached item, caching and returning a new instance instead."}]},{"inlineContent":[{"text":"Requesting a cached item before the timeout period ends returns the currently cached item and effectively restarts the clock for that item.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Like registrations, setting a time to live on a dependency only affects the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"next"}]},{"type":"text","text":" resolution for that item. Anything already resolved and referenced stays resolved and referenced."}]},{"type":"heading","text":"Reset","anchor":"Reset","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"As mentioned earlier in the discussion on custom scopes, individual scope caches on a container can be reset (cleared) if needed."}]},{"code":["\/\/ clear the default cached scope","Container.shared.manager.reset(scope: .cached)","\/\/ clear everything cached by the custom session scope","Container.shared.manager.reset(scope: .session)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"You can reset the cache for ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"all"}]},{"text":" of the scopes managed by that container.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["Container.shared.manager.reset(options: .scope)"]},{"inlineContent":[{"type":"text","text":"As mentioned earlier, Singletons are global and they’re "},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"type":"text","text":" managed by any particular container. If needed, the singleton scope can be reset directly."}],"type":"paragraph"},{"syntax":"swift","code":["Scope.singleton.reset()"],"type":"codeListing"},{"type":"aside","style":"important","content":[{"inlineContent":[{"type":"text","text":"Resetting a container or scope has no effect whatsoever on anything that’s already been resolved by Factory. It only ensures that the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"next"}]},{"type":"text","text":" time a Factory on that container is asked to resolve a dependency that dependency will be a new instance."}],"type":"paragraph"}],"name":"Important"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"topicSections":[{"title":"Scope Class Definitions","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Scope","doc:\/\/Factory\/documentation\/Factory\/Scope\/Cached-swift.class","doc:\/\/Factory\/documentation\/Factory\/Scope\/Graph-swift.class","doc:\/\/Factory\/documentation\/Factory\/Scope\/Shared-swift.class","doc:\/\/Factory\/documentation\/Factory\/Scope\/Singleton-swift.class","doc:\/\/Factory\/documentation\/Factory\/Scope\/Unique-swift.class"]}],"references":{"doc://Factory/documentation/Factory/Cycle":{"kind":"article","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Cycle","title":"Resolution Cycles","url":"\/documentation\/factory\/cycle","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"role":"article"},"doc://Factory/documentation/Factory/Scope/Singleton-swift.class":{"abstract":[{"type":"text","text":"Defines the singleton scope. The same instance will always be returned by the factory."}],"navigatorTitle":[{"text":"Singleton","kind":"identifier"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope\/Singleton-swift.class","url":"\/documentation\/factory\/scope\/singleton-swift.class","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Singleton"}],"type":"topic","role":"symbol","title":"Scope.Singleton","kind":"symbol"},"doc://Factory/documentation/Factory/GettingStarted":{"url":"\/documentation\/factory\/gettingstarted","kind":"article","identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"type":"topic","title":"Getting Started","role":"collectionGroup"},"doc://Factory/documentation/Factory/Scope/Graph-swift.class":{"type":"topic","url":"\/documentation\/factory\/scope\/graph-swift.class","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Graph"}],"title":"Scope.Graph","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope\/Graph-swift.class","navigatorTitle":[{"text":"Graph","kind":"identifier"}],"abstract":[{"text":"Defines the graph scope. A single instance of a given type will be returned during a given resolution cycle.","type":"text"}],"role":"symbol","kind":"symbol"},"doc://Factory/documentation/Factory/Scope":{"navigatorTitle":[{"text":"Scope","kind":"identifier"}],"url":"\/documentation\/factory\/scope","title":"Scope","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Scope","kind":"identifier"}],"abstract":[{"text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,","type":"text"},{"type":"text","text":" "},{"text":"including ","type":"text"},{"type":"codeVoice","code":"Singleton"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Cached"},{"type":"text","text":", "},{"code":"Graph","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Shared","type":"codeVoice"},{"type":"text","text":"."}],"kind":"symbol","role":"symbol"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","url":"\/documentation\/factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}]},"doc://Factory/documentation/Factory/Testing":{"title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"url":"\/documentation\/factory\/testing","kind":"article","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","role":"article"},"doc://Factory/documentation/Factory/Scope/Cached-swift.class":{"type":"topic","url":"\/documentation\/factory\/scope\/cached-swift.class","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"Cached","kind":"identifier"}],"title":"Scope.Cached","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope\/Cached-swift.class","navigatorTitle":[{"kind":"identifier","text":"Cached"}],"abstract":[{"type":"text","text":"Defines a cached scope. The same instance will be returned by the factory until the cache is reset."}],"role":"symbol","kind":"symbol"},"doc://Factory/documentation/Factory/Containers":{"role":"article","abstract":[{"type":"text","text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?"}],"kind":"article","identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","title":"Containers","type":"topic","url":"\/documentation\/factory\/containers"},"doc://Factory/documentation/Factory/Scope/Shared-swift.class":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Shared"}],"type":"topic","url":"\/documentation\/factory\/scope\/shared-swift.class","title":"Scope.Shared","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope\/Shared-swift.class","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Shared"}],"abstract":[{"text":"Defines a shared (weak) scope. The same instance will be returned by the factory as long as someone maintains a strong reference.","type":"text"}],"role":"symbol"},"doc://Factory/documentation/Factory/Scope/Unique-swift.class":{"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Unique","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope\/Unique-swift.class","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"Unique","kind":"identifier"}],"title":"Scope.Unique","abstract":[{"type":"text","text":"Defines the unique scope. A new instance of a given type will be returned on every resolution cycle."}],"url":"\/documentation\/factory\/scope\/unique-swift.class"}}}