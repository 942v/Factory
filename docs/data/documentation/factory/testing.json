{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory has a quite a few additional enhancements added to make unit testing and user interface testing simpler and easier. Some, like "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},{"type":"text","text":" you may have already seen and used. Others, like pushing\/popping container state, resetting, and so on, are discussed below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But before we look at those, it’s important to first understand Xcode’s test process and environment, and consider what that means when writing your own unit tests using Factory."}]},{"anchor":"The-Unit-Test-Environment","level":2,"type":"heading","text":"The Unit Test Environment"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you run a unit test, Xcode is launching and running your app in order to provide a relevant context for your test code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This means that application main ran, that the application delegate’s "},{"type":"codeVoice","code":"didFinishLaunchingWithOptions"},{"type":"text","text":" function ran, and all the code needed to get to your first screen ran. When your app reaches a state where RunLoop.main starts idling and waiting for user input, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"then"}]},{"type":"text","text":" XCTest will start constructing test classes and running test cases."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of which means that a LOT of code has already run before your first test has even fired."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Including dependency injection code."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when writing unit tests we need to keep in mind what our initial runtime application environment looks like, what Factory registrations may have already have occurred, and in particular, if any of those registrations were scoped and cached."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is specially true when dealing with "},{"type":"emphasis","inlineContent":[{"type":"text","text":"singletons"}]},{"type":"text","text":". But again, let’s save that topic for a bit later."}]},{"anchor":"Changing-Not-Rebuilding","level":2,"type":"heading","text":"Changing, Not Rebuilding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So our environment exists, running and awaiting our first test. All of our original runtime dependency injection extensions and registrations are also out there, ready to be resolved and injected when needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And that’s great. A cryptographic hashing dependency can be used in production and in test with no repercussions. We don’t need to change a thing. And in fact, the more working code we can test in its shipping state, the better."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That said, other services, like an analytics engine, may want to be swapped out during testing. Again, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},{"type":"text","text":" can help with that."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But we’re here to test, and one thing that we probably "},{"type":"emphasis","inlineContent":[{"type":"text","text":"do"}]},{"type":"text","text":" care about is the code is talks to our APIs and other services. Those are the classes and services that we’re probably going to want to mock and reregister so we can test our view models and business logic against stable test data."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Again, Factory makes that easy."}]},{"type":"codeListing","syntax":"swift","code":["func testNoAccounts() async {","    \/\/ register a mock","    Container.shared.accountLoading.register { MockNoAccounts() }","    \/\/ instantiate the model that uses the mock","    let model = Container.shared.accountsViewModel()","    \/\/ and test...","    await model.load()","    XCTAssertTrue(model.isLoaded)","    XCTAssertTrue(model.isEmpty)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Only if we’re running a lot of tests like this then we’re going to making a lot of changes to the dependency injection environment. And that’s problematic. We need to make sure that a change made in one test doesn’t affect a later test that relied on the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"original"}]},{"type":"text","text":" object that demonstrated a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"different"}]},{"type":"text","text":" behavior."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Fortunately, Factory can help with that."}]},{"anchor":"Pushing-and-Popping-State","level":2,"type":"heading","text":"Pushing and Popping State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your unit test setUp function you can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"push"}]},{"type":"text","text":" the current state of the registration system and then register and test anything you want."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then in teardown you can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pop"}]},{"type":"text","text":" the stack, eliminating all of your changes and restoring the container to its original state before the push."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This lets each set of tests start from the same state, irregardless of what any prior test had changed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example assumes we’re using the shared container."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        super.setUp()","        Container.shared.manager.push()","        Container.shared.setupMocks()","    }","    ","    override func tearDown() {","        super.tearDown()","        Container.shared.manager.pop()","    }","    ","    func testNoAccounts() async {","        Container.shared.accountLoading.register { MockNoAccounts() }","        let model = Container.shared.accountsViewModel()","        await model.load()","        XCTAssertTrue(model.isLoaded)","        XCTAssertTrue(model.isEmpty)","    }","","    func testError() async {","        Container.shared.accountLoading.register { MockAccountError(404) }","        let model = Container.shared.accountsViewModel()","        await model.load()","        XCTAssertTrue(model.isError)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s pretty much it. Our "},{"type":"codeVoice","code":"AccountsViewModel"},{"type":"text","text":" depended on an "},{"type":"codeVoice","code":"AccountsLoading"},{"type":"text","text":" service."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Change the service provided and we change the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"data"}]},{"type":"text","text":" provided. Change the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"data"}]},{"type":"text","text":" provided and we change our view model’s behavior."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then we test the results to see if everything matches up with our expectations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the above is just one way of doing things. If, for example, our "},{"type":"codeVoice","code":"AccountLoader"},{"type":"text","text":" service depended on a custom network layer, we could reach further down the stack."}]},{"type":"codeListing","syntax":"swift","code":["func testNoAccounts() async throws {","    let json = #\"{ \"accounts\": [] }\"#","    Container.shared.networking.register { MockJSON(json) }","    let model = Container.shared.accountsViewModel()","    \/\/ as before","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We create the "},{"type":"codeVoice","code":"AccountsViewModel"},{"type":"text","text":", the view model injects the "},{"type":"codeVoice","code":"AccountLoading"},{"type":"text","text":" service, and that service injects our mock network service."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory makes reaching deep into a dependency tree simple and easy."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And keep in mind that Factory can also help you see what’s "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inside"}]},{"type":"text","text":" that dependency tree. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging"},{"type":"text","text":" for more information."}]},{"anchor":"Rebuilding-The-Container","level":2,"type":"heading","text":"Rebuilding The Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your unit test setUp function you can also just create a new container and start over from scratch. No teardown needed."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        super.setUp()","        Container.shared = Container()","        Container.shared.setupMocks()","    }","    ","    func testNoAccounts() throws {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that this is pretty safe to do in the majority of cases. Your application has already launched, obtained what it needed, and is now idling."}]},{"anchor":"Passed-Containers","level":2,"type":"heading","text":"Passed Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also pass the container into the view model itself."}]},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    var container: Container!","","    override func setUp() {","        super.setUp()","        container = Container()","        container.setupMocks()","    }","    ","    func testSomething() throws {","        container.myServiceType.register(factory: { MockService() })","        let model = MyViewModel(container: container)","        model.load()","        XCTAssertTrue(model.isLoaded)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This does, of course, assume that you structured your app appropriately."}]},{"anchor":"Common-Setup","level":2,"type":"heading","text":"Common Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As shown in the previous examples, if we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    func setupMocks() {","        myService.register { MockServiceN(4) }","        sharedService.register { MockService2() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then again, if we always want the same result whenever we’re previewing any screen, we just set it up once in the autoRegister function using a "},{"type":"codeVoice","code":"preview"},{"type":"text","text":" context:"}]},{"type":"codeListing","syntax":"swift","code":["extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myService.onPreview { MockServiceN(4)MockServiceN(1) }","        sharedService.onPreview { MockService2() }","        #endif","    }","}"]},{"anchor":"Singletons","level":2,"type":"heading","text":"Singletons"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s talk singletons. The singleton scope cache is global, meaning that it’s "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" managed by any specific container."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That being the case, neither the push\/pull mechanism or the container rebuilding mechanisms described above will clear any cached singleton instances."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Singletons are, after all, expected to be singletons."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So what to do about it? Well, if needed we can reset every cached singleton with just a single method call by calling reset on that particular scope."}]},{"type":"codeListing","syntax":"swift","code":["Scope.singleton.reset()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or you can reset a specific singleton by reaching out to its factory."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ reset everything for that factory","Container.shared.someSingletonFactory.reset()","\/\/ reset just the scope cache","Container.shared.someSingletonFactory.reset(options: .scope)","\/\/ or simply register a new instance","Container.shared.someSingletonFactory.register { MyNewMock() }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with “normal” code, singletons should only be used when there’s an overriding need for their to be one and only one instance of an object."}]},{"anchor":"Xcode-UI-Testing","level":2,"type":"heading","text":"Xcode UI Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can use the auto-registration feature mentioned earlier to help us out when running UI Tests. The test case is fairly straightforward."}]},{"type":"codeListing","syntax":"swift","code":["import XCTest","","final class FactoryDemoUITests: XCTestCase {","    func testExample() throws {","        let app = XCUIApplication()","        app.launchArguments.append(\"mock1\")","        app.launch()","","        let welcome = app.staticTexts[\"Mock Number 1! for Michael\"]","        XCTAssert(welcome.exists)","    }","}   "]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then in the application we check the launch arguments to see what registrations we might want to change."}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Factory","","extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        if ProcessInfo().arguments.contains(\"mock1\") {","            myServiceType.register { MockServiceN(1) }","        }","        #endif","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or you can simplify things with an "},{"type":"codeVoice","code":"arg"},{"type":"text","text":" context that accomplishes the same thing."}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Factory","","extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myServiceType.onArg(\"mock1\") { ","            MockServiceN(1)","        }","        #endif","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are many contexts for testing, previews, and even UITesting. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},{"type":"text","text":" for more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Obviously, one can add as many different test cases and registrations as needed."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Testing","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Testing","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Development and Testing","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Contexts","doc:\/\/Factory\/documentation\/Factory\/Debugging","doc:\/\/Factory\/documentation\/Factory\/Chains"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Previews":{"role":"article","title":"SwiftUI Previews","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews","kind":"article","type":"topic","url":"\/documentation\/factory\/previews"},"doc://Factory/documentation/Factory/Chains":{"role":"article","title":"Circular Dependency Chains","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Chains","kind":"article","type":"topic","url":"\/documentation\/factory\/chains"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Debugging":{"role":"article","title":"Debugging","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging","kind":"article","type":"topic","url":"\/documentation\/factory\/debugging"},"doc://Factory/documentation/Factory/Contexts":{"role":"article","title":"Contexts","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts","kind":"article","type":"topic","url":"\/documentation\/factory\/contexts"}}}