{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When Factory was redesigned for Factory 2.0 the decision was made to provide many of Factory’s configuration options using a modifier syntax similar to that of SwiftUI."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Modifiers make it easy to define a Factory’s options in the Factory registration…"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After the fact, when the application runs…"}]},{"type":"codeListing","syntax":"swift","code":["extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myService","            .onArg(\"mock0\") { EmptyService() }","            .onArg(\"mock1\") { MockServiceN(1) }","            .onArg(\"error\") { MockError(404) }","        #endif","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or even under direct program control…"}]},{"type":"codeListing","syntax":"swift","code":["func logout() {","    ...","    Container.shared.userProviding.register { nil }","    ...","}"]},{"anchor":"Modifiers","level":2,"type":"heading","text":"Modifiers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory provides quite a few modifiers for your use, but they basically break down into a few different categories:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Scopes: Defines just how long a particular dependency persists."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Registrations: Updating or changing the dependency to be provided."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Contexts: Defines Factory overrides that should occur when the app is running is a spcific context."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Decorators: Defines code to be run whenever a dependency is resolved."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Resets: Reseting a Factory’s registrations or scope cache."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Plus a few more, but that covers most of them."}]},{"anchor":"Resolving-a-Factory","level":2,"type":"heading","text":"Resolving a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As mentioned in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted"},{"type":"text","text":", there are many ways to resolve a Factory. Here’s a simple example that resolves the "},{"type":"codeVoice","code":"myService"},{"type":"text","text":" Factory we defined above."}]},{"type":"codeListing","syntax":"swift","code":["let myService = Container.shared.myService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code asks "},{"type":"codeVoice","code":"Container.shared.myService"},{"type":"text","text":" for a Factory, and then asks the Factory to resolve itself using its "},{"type":"codeVoice","code":"callAsFunction"},{"type":"text","text":" resolution shortcut."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But consider the original definition."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"myService"},{"type":"text","text":" variable is a computed function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When it’s ’called, the "},{"type":"codeVoice","code":"self { MyService() }"},{"type":"text","text":" code asks the parent container to build a Factory with the passed closure. That Factory is modified with a scope option, and then again with an "},{"type":"codeVoice","code":"onTest"},{"type":"text","text":" context modifier."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That fully configure Factory is what’s returned to the caller, either to be modified further, or resolved as we’ve done here."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That may seem like a lot of overhead, but it actually isn’t. As we’ve mentioned elsewhere, Factory’s are like SwftUI Views. Its structs and modifiers are lightweight and transitory value types, created when needed and then immediately discarded once their purpose has been served."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is, however, one consideration."}]},{"anchor":"The-Factory-Wins","level":2,"type":"heading","text":"The Factory Wins"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say, for example, that we run the following code to change the factory context during a unit test."}]},{"type":"codeListing","syntax":"swift","code":["Container.shared.myService.onTest { NullAnalyticsEngine() }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then a bit further down we resolve our service."}]},{"type":"codeListing","syntax":"swift","code":["let myService = Container.shared.myService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the question is: Do we now have an instance of "},{"type":"codeVoice","code":"NullAnalyticsEngine"},{"type":"text","text":", or "},{"type":"codeVoice","code":"MockAnalyticsEngine"},{"type":"text","text":"?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As may be apparent from the section title, we actually have an instance of "},{"type":"codeVoice","code":"MockAnalyticsEngine"},{"type":"text","text":". But why? Didn’t we just change it?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We did. But then we called "},{"type":"codeVoice","code":"Container.shared.myService"},{"type":"text","text":" again, which built a new Factory, which defined a scope, and which "},{"type":"strong","inlineContent":[{"type":"text","text":"defined"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"onTest"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And so Factory went with it’s most recent definition."}]},{"anchor":"SwiftUI","level":2,"type":"heading","text":"SwiftUI"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar behavior can be seen in SwiftUI itself."}]},{"type":"codeListing","syntax":"swift","code":["struct innerView: View {","    var body: some View {","        Text(\"Hello\")","            .foregroundColor(.red)","    }","}","struct outerView: View {","    var body: some View {","        innerView()","            .foregroundColor(.green)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here the color of the “Hello” text is red, dispite our attempt to override it. The innermost bound property wins."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So what can we do?"}]},{"anchor":"External-Setup","level":2,"type":"heading","text":"External Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One solution is to be careful what we put inside our factory definition."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then we add anything we might want to change later as an extenally defined option."}]},{"type":"codeListing","syntax":"swift","code":["extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myService","            .onTest { MockAnalyticsEngine() }","        #endif","    }","}"]},{"anchor":"Chaining","level":2,"type":"heading","text":"Chaining"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another solution that might work in some circumstances is chaining."}]},{"type":"codeListing","syntax":"swift","code":["let mySerivce = Container.shared.myService","    .onTest { NullAnalyticsEngine() }","    .resolve()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way the internal definitions are applied, then onTest is updated, and then we immediately resolve the serivce using the latest definition."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or we can use a new modifier added to Factory 2.1."}]},{"anchor":"Once","level":2,"type":"heading","text":"Once"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"once"},{"type":"text","text":" modifier basically tells the system that anything that occurs before it should only be done "},{"type":"strong","inlineContent":[{"type":"text","text":"once"}]}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","            .once()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when we do:"}]},{"type":"codeListing","syntax":"swift","code":["Container.shared.myService.onTest { NullAnalyticsEngine() }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our Factory is constructed, the singleton is applied, the internal onTest is applied, and then the new onTest is applied."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then later, when we resolve our service."}]},{"type":"codeListing","syntax":"swift","code":["let myService = Container.shared.myService()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our Factory is constructed, but the internal singleton has already occurred once, so it’s ignored. Similarly, the internal onTest has already occurred once, so it too is ignored."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which means that we get our "},{"type":"codeVoice","code":"NullAnalyticsEngine"},{"type":"text","text":", just like we wanted."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once is a useful tool to have around, but in reality it’s probably best simply to be careful in regard to what goes into our basic Factory definition."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/factory\/modifiers"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Modifiers","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Considerations when defining and redefining a Factory’s behavior."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Factory Modifiers","role":"article","modules":[{"name":"Factory"}]},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"title":"Advanced Topics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Design","doc:\/\/Factory\/documentation\/Factory\/Modules","doc:\/\/Factory\/documentation\/Factory\/Cycle","doc:\/\/Factory\/documentation\/Factory\/Optionals","doc:\/\/Factory\/documentation\/Factory\/Functional"],"generated":true}],"references":{"doc://Factory/documentation/Factory/Modules":{"role":"article","title":"Modular Development","abstract":[{"type":"text","text":"Using Factory in a project with multiple modules."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Modules","kind":"article","type":"topic","url":"\/documentation\/factory\/modules"},"doc://Factory/documentation/Factory/Optionals":{"role":"article","title":"Optionals and Dynamic Registration","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Optionals","kind":"article","type":"topic","url":"\/documentation\/factory\/optionals"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Design":{"role":"article","title":"Designing Factory","abstract":[{"type":"text","text":"Rationale behind the design decisions made in Factory 1.0 and 2.0"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Design","kind":"article","type":"topic","url":"\/documentation\/factory\/design"},"doc://Factory/documentation/Factory/GettingStarted":{"role":"collectionGroup","title":"Getting Started","abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/factory\/gettingstarted"},"doc://Factory/documentation/Factory/Cycle":{"role":"article","title":"Resolution Cycles","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Cycle","kind":"article","type":"topic","url":"\/documentation\/factory\/cycle"},"doc://Factory/documentation/Factory/Functional":{"role":"article","title":"Functional Injection","abstract":[{"type":"text","text":"Factory can inject more than service classes and structs."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Functional","kind":"article","type":"topic","url":"\/documentation\/factory\/functional"}}}